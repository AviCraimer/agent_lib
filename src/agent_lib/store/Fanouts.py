"""Parallel task coordination for Store.

Fanouts manage the pattern where multiple agents are given tasks in parallel,
and when all tasks complete (success or failure), a callback is triggered.
"""

# pyright: reportPrivateUsage=false
# This module is an internal Store component that needs access to Store internals.

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from agent_lib.store.Store import Store


@dataclass
class TaskResult:
    resolved: bool = False
    success: bool | None = None  # None until resolved
    result: Any = (
        None  # This is what is generated by the LLM agent. If it's a failure this is None. If it is a failure, this can include a reason for the failure or error message or exception object.
    )


@dataclass
class FanoutResult:
    """Result passed to on_complete callback."""

    fanout_id: str
    fanout_description: str
    tasks: dict[str, TaskResult]
    success_count: int = 0
    failure_count: int = 0

    @property
    def all_succeeded(self) -> bool:
        """Check if all tasks completed successfully."""
        return self.failure_count == 0


class Fanouts:
    """Manages parallel task coordination.

    Usage:
        # Create a fanout tracking multiple tasks
        store._fanouts.create(
            fanout_id="batch_1",
            task_names=["planner", "executor", "validator"],
            on_complete=handle_batch_complete
        )

        # Get curried resolvers for each agent
        resolve_planner = store._fanouts.make_resolver("batch_1", "planner")
        agent.available_actions["resolve"] = resolve_planner

        # Agent calls with simple payload
        resolve(TaskResult(success=True, result=plan_data))
    """

    _store: Store
    registry: dict[str, dict[str, TaskResult]]  # fanout_id -> task_id -> task_result
    _callbacks: dict[str, Callable[[FanoutResult], None]]  # fanout_id -> on_complete
    _unsubscribers: dict[str, Callable[[], None]]  # fanout_id -> unsubscribe fn

    def __init__(self, store: Store) -> None:
        self._store = store
        self.registry = {}
        self._callbacks = {}
        self._unsubscribers = {}

    def create(
        self,
        fanout_id: str,
        fanout_description: str,
        task_names: list[str],
        on_complete: Callable[[FanoutResult], None],
    ) -> None:
        """Create a fanout tracking multiple tasks.

        Sets up a subscriber watching registry[fanout_id] for completion.

        Args:
            fanout_id: Unique identifier for this fanout
            task_names: Names of tasks to track
            on_complete: Callback when all tasks resolve
        """
        if fanout_id in self.registry:
            raise ValueError(f"Fanout '{fanout_id}' already exists")

        # Initialize registry entry with pending tasks
        self.registry[fanout_id] = {name: TaskResult() for name in task_names}
        self._callbacks[fanout_id] = on_complete

        # Subscribe to watch for completion
        def check_completion(_affects: Callable[[str], bool]) -> None:
            self._check_completion(fanout_id, fanout_description)

        unsubscribe = self._store.subscribe(check_completion)
        self._unsubscribers[fanout_id] = unsubscribe

    def make_resolver(
        self, fanout_id: str, task_name: str
    ) -> Callable[[TaskResult], None]:
        """Factory returning a curried action for resolving a specific task.

        The returned callable:
        1. Updates registry[fanout_id][task_name]
        2. Returns scope frozenset({"_fanouts.registry.<fanout_id>.<task_name>"})
        3. Triggers normal Store notification flow

        Args:
            fanout_id: The fanout this task belongs to
            task_name: The specific task name

        Returns:
            A callable that takes TaskResult and resolves this specific task
        """
        if fanout_id not in self.registry:
            raise ValueError(f"Fanout '{fanout_id}' does not exist")
        if task_name not in self.registry[fanout_id]:
            raise ValueError(f"Task '{task_name}' not in fanout '{fanout_id}'")

        def handler(store: Store, task_result: TaskResult) -> frozenset[str]:
            status = store._fanouts.registry[fanout_id][task_name]
            if status.resolved:
                raise RuntimeError(
                    f"Task '{task_name}' in fanout '{fanout_id}' already resolved"
                )
            status.resolved = True
            status.success = task_result.success
            status.result = task_result.result

            return frozenset({f"_fanouts.registry.{fanout_id}.{task_name}"})

        def bound(task_result: TaskResult) -> None:
            delta = self._store._process_action(handler, task_result)
            self._store._subscribers.notify(delta)

        return bound

    def _check_completion(
        self, fanout_id: str, fanout_description: str
    ) -> None:
        """Subscriber callback - checks if all tasks resolved, fires on_complete.

        Args:
            fanout_id: The fanout to check
            fanout_description: Description of the fanout
        """
        if fanout_id not in self.registry:
            return

        tasks = self.registry[fanout_id]

        # Check if all tasks are resolved
        if not all(task.resolved for task in tasks.values()):
            return

        # Build result
        result = FanoutResult(
            fanout_id=fanout_id,
            fanout_description=fanout_description,
            tasks=tasks.copy(),
            success_count=sum(1 for task in tasks.values() if task.success),
            failure_count=sum(1 for task in tasks.values() if not task.success),
        )

        # Cleanup
        if fanout_id in self._unsubscribers:
            self._unsubscribers[fanout_id]()
            del self._unsubscribers[fanout_id]

        callback = self._callbacks.pop(fanout_id, None)

        # Fire callback
        if callback:
            callback(result)
